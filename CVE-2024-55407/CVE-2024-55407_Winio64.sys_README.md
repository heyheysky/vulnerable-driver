# Vulnerable Driver WinIo64.sys in ITE IO Access - 1.0.0.0

---

Many vulnerability exists in driver WinIo64.sys, which allows low-privileged users read and write arbitary i/o port via specially crafted IOCTL requests. This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  



## version

1.0.0.0

## Vulnerability causes

WinIo64.sys provides the functionality of read/write I/O ports, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

~~~c
__int64 __fastcall sub_111A0(__int64 a1, IRP *a2)
{
  struct _IRP *MasterIrp; // [rsp+28h] [rbp-30h]
  ULONG Length; // [rsp+30h] [rbp-28h]
  struct _IO_STACK_LOCATION *CurrentStackLocation; // [rsp+38h] [rbp-20h]
  unsigned int Status; // [rsp+44h] [rbp-14h]
  UCHAR MajorFunction; // [rsp+48h] [rbp-10h]

  a2->IoStatus.Information = 0i64;
  DbgPrint("Entering WinIoDispatch");
  a2->IoStatus.Status = 0;
  a2->IoStatus.Information = 0i64;
  CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
  Length = CurrentStackLocation->Parameters.Read.Length;
  MasterIrp = a2->AssociatedIrp.MasterIrp;
  MajorFunction = CurrentStackLocation->MajorFunction;
  if ( CurrentStackLocation->MajorFunction )
  {
    if ( MajorFunction == 2 )
    {
      DbgPrint("IRP_MJ_CLOSE\n");
    }
    else if ( MajorFunction == 14 )
    {
      DbgPrint("IRP_MJ_DEVICE_CONTROL");
      if ( CurrentStackLocation->Parameters.Read.ByteOffset.LowPart == -1673501696 )
      {
        DbgPrint("IOCTL_READ_PORT_UCHAR");
        a2->IoStatus.Information = Length;
        LOBYTE(MasterIrp->Type) = sub_11010(LOBYTE(MasterIrp->Type));
      }
      else if ( CurrentStackLocation->Parameters.Read.ByteOffset.LowPart == -1673485248 )
      {
        DbgPrint("IOCTL_WRITE_PORT_UCHAR");
        a2->IoStatus.Information = Length;
        sub_11030(*(unsigned int *)&MasterIrp->Type, *((unsigned __int8 *)&MasterIrp->Size + 2));
      }
      else
      {
        DbgPrint("ERROR: Unknown IRP_MJ_DEVICE_CONTROL");
        a2->IoStatus.Information = 0i64;
        a2->IoStatus.Status = -1073741811;
      }
    }
  }
  else
  {
    DbgPrint("IRP_MJ_CREATE\n");
  }
  Status = a2->IoStatus.Status;
  IofCompleteRequest(a2, 0);
  DbgPrint("Leaving WinIoDispatch");
  return Status;
}
~~~

### IOCTL  0x9C406400

This IOCTL code triggers the port in operation.

~~~c
   else if ( MajorFunction == 14 )
    {
      DbgPrint("IRP_MJ_DEVICE_CONTROL");
      if ( CurrentStackLocation->Parameters.Read.ByteOffset.LowPart == 0x9C406400 )
      {
        DbgPrint("IOCTL_READ_PORT_UCHAR");
        a2->IoStatus.Information = Length;
        LOBYTE(MasterIrp->Type) = sub_11010(LOBYTE(MasterIrp->Type));
      }
~~~

### IOCTL 0x9C40A440

This code triggers port out operation. 

```c
      else if ( CurrentStackLocation->Parameters.Read.ByteOffset.LowPart == 0x9C40A440 )
      {
        DbgPrint("IOCTL_WRITE_PORT_UCHAR");
        a2->IoStatus.Information = Length;
        sub_11030(*(_DWORD *)&MasterIrp->Type, *((_BYTE *)&MasterIrp->Size + 2));
      }
```

