# Vulnerable Driver 690b33e1-0462-4e84-9bea-c7552b45432a.sys in Asus GPU Tweak II 1.0.0.0

---

Many vulnerability exits in driver 690b33e1-0462-4e84-9bea-c7552b45432a.sys, which allows low-privileged users to map arbitrary physical memory, read and write arbitary i/o port via specially crafted IOCTL requests. This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  



## version

1.0.0.0

## Vulnerability causes

690b33e1-0462-4e84-9bea-c7552b45432a.sys  provides the functionality of mapping physical memory and read/write I/O ports, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

~~~c
__int64 __fastcall ioctler(__int64 a1, IRP *a2)
{
  char v2; // al
  ULONG Options; // [rsp+30h] [rbp-98h]
  int v5[2]; // [rsp+38h] [rbp-90h] BYREF
  int v6[2]; // [rsp+40h] [rbp-88h]
  int v7[2]; // [rsp+48h] [rbp-80h] BYREF
  int v8[2]; // [rsp+50h] [rbp-78h] BYREF
  PVOID v9[3]; // [rsp+58h] [rbp-70h] BYREF
  unsigned __int16 v10; // [rsp+70h] [rbp-58h] BYREF
  unsigned int v11; // [rsp+72h] [rbp-56h]
  char v12; // [rsp+76h] [rbp-52h]
  ULONG Length; // [rsp+78h] [rbp-50h]
  struct _IO_STACK_LOCATION *CurrentStackLocation; // [rsp+80h] [rbp-48h]
  DWORD LowPart; // [rsp+88h] [rbp-40h]
  unsigned int Status; // [rsp+8Ch] [rbp-3Ch]
  int *p_Type; // [rsp+90h] [rbp-38h]
  UCHAR MajorFunction; // [rsp+98h] [rbp-30h]
  DWORD v19; // [rsp+9Ch] [rbp-2Ch]
  char v20; // [rsp+A0h] [rbp-28h]
  char v21; // [rsp+A4h] [rbp-24h]

  v9[1] = 0i64;
  v9[2] = 0i64;
  DbgPrint("Entering WinIoDispatch");
  a2->IoStatus.Status = 0;
  a2->IoStatus.Information = 0i64;
  CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
  p_Type = (int *)&a2->AssociatedIrp.MasterIrp->Type;
  Options = CurrentStackLocation->Parameters.Create.Options;
  Length = CurrentStackLocation->Parameters.Read.Length;
  MajorFunction = CurrentStackLocation->MajorFunction;
  if ( MajorFunction )
  {
    if ( MajorFunction == 2 )
    {
      DbgPrint("IRP_MJ_CLOSE");
    }
    else if ( MajorFunction == 14 )
    {
      DbgPrint("IRP_MJ_DEVICE_CONTROL");
      LowPart = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
      v19 = LowPart;
      if ( LowPart == -2146426816 )
      {
        DbgPrint("IOCTL_WINIO_MAPPHYSTOLIN");
        if ( Options )
        {
          qmemcpy(v5, p_Type, Options);
          v2 = IoIs32bitProcess(a2);
          Status = sub_11710(*(PHYSICAL_ADDRESS *)v6, *(SIZE_T *)v5, (PVOID *)v8, (void **)v7, v9, v2);
          if ( (Status & 0x80000000) == 0 )
          {
            qmemcpy(p_Type, v5, Options);
            a2->IoStatus.Information = Options;
          }
          a2->IoStatus.Status = Status;
        }
        else
        {
          a2->IoStatus.Status = -1073741811;
        }
      }
      else
      {
        switch ( v19 )
        {
          case 0x80102044:
            DbgPrint("IOCTL_WINIO_UNMAPPHYSADDR");
            if ( Options )
            {
              qmemcpy(v5, p_Type, Options);
              Status = sub_11B70(*(_QWORD *)v7, *(_QWORD *)v8, v9[0]);
              a2->IoStatus.Status = Status;
            }
            else
            {
              a2->IoStatus.Status = -1073741811;
            }
            break;
          case 0x80102050:
            DbgPrint("IOCTL_WINIO_READPORT");
            if ( Options )
            {
              qmemcpy(&v10, p_Type, Options);
              v21 = v12;
              if ( v12 == 1 )
              {
                v11 = (unsigned __int8)sub_115D0(v10);
              }
              else if ( v21 == 2 )
              {
                v11 = (unsigned __int16)sub_115F0(v10);
              }
              else if ( v21 == 4 )
              {
                v11 = sub_11610(v10);
              }
              *p_Type = v11;
              a2->IoStatus.Information = 4i64;
            }
            else
            {
              a2->IoStatus.Status = -1073741811;
            }
            break;
          case 0x80102054:
            DbgPrint("IOCTL_WINIO_WRITEPORT");
            if ( Options )
            {
              qmemcpy(&v10, p_Type, Options);
              v20 = v12;
              if ( v12 == 1 )
              {
                sub_11630(v10, (unsigned __int8)v11);
              }
              else if ( v20 == 2 )
              {
                sub_11650(v10, (unsigned __int16)v11);
              }
              else if ( v20 == 4 )
              {
                sub_11670(v10, v11);
              }
            }
            else
            {
              a2->IoStatus.Status = -1073741811;
            }
            break;
          default:
            DbgPrint("ERROR: Unknown IRP_MJ_DEVICE_CONTROL");
            a2->IoStatus.Status = -1073741811;
            break;
        }
      }
    }
  }
  else
  {
    DbgPrint("IRP_MJ_CREATE");
  }
  Status = a2->IoStatus.Status;
  IofCompleteRequest(a2, 0);
  DbgPrint("Leaving WinIoDispatch");
  return Status;
}
~~~

### IOCTL  0x80102040

This IOCTL code triggers the memory mapping

~~~c
__int64 __fastcall sub_11710(PHYSICAL_ADDRESS a1, SIZE_T a2, PVOID *a3, void **a4, PVOID *Object, char a6)
{
  PHYSICAL_ADDRESS BusAddress; // [rsp+58h] [rbp-190h] BYREF
  ULONG AddressSpace; // [rsp+60h] [rbp-188h] BYREF
  int v9; // [rsp+64h] [rbp-184h]
  BOOLEAN v10; // [rsp+6Ch] [rbp-17Ch]
  PHYSICAL_ADDRESS TranslatedAddress; // [rsp+70h] [rbp-178h] BYREF
  union _LARGE_INTEGER SectionOffset; // [rsp+78h] [rbp-170h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+80h] [rbp-168h] BYREF
  PVOID BaseAddress; // [rsp+1C0h] [rbp-28h] BYREF
  NTSTATUS v15; // [rsp+1C8h] [rbp-20h]
  BOOLEAN v16; // [rsp+1CCh] [rbp-1Ch]
  struct _UNICODE_STRING DestinationString; // [rsp+1D0h] [rbp-18h] BYREF
  SIZE_T CommitSize; // [rsp+1F8h] [rbp+10h] BYREF
  PVOID *v20; // [rsp+200h] [rbp+18h]
  PHANDLE SectionHandle; // [rsp+208h] [rbp+20h]

  SectionHandle = a4;
  v20 = a3;
  CommitSize = a2;
  BaseAddress = 0i64;
  v9 = 0;
  DbgPrint("Entering MapPhysicalMemoryToLinearSpace");
  RtlInitUnicodeString(&DestinationString, L"\\Device\\PhysicalMemory");
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.SecurityDescriptor = 0i64;
  ObjectAttributes.SecurityQualityOfService = 0i64;
  *SectionHandle = 0i64;
  *Object = 0i64;
  v15 = ZwOpenSection(SectionHandle, 0xF001Fu, &ObjectAttributes);
  if ( v15 < 0 )
  {
    DbgPrint("ERROR: ZwOpenSection failed");
  }
  else
  {
    v15 = ObReferenceObjectByHandle(*SectionHandle, 0xF001Fu, 0i64, 0, Object, 0i64);
    if ( v15 < 0 )
    {
      DbgPrint("ERROR: ObReferenceObjectByHandle failed");
    }
    else
    {
      DbgPrint("pPhysAddress = %llx", a1.QuadPart);
      BusAddress = a1;
      DbgPrint("pStartPhysAddress = %llx", a1.QuadPart);
      TranslatedAddress.QuadPart = CommitSize + a1.QuadPart;
      DbgPrint("pEndPhysAddress = %llx", CommitSize + a1.QuadPart);
      AddressSpace = 0;
      v10 = HalTranslateBusAddress(Isa, 0, a1, &AddressSpace, &BusAddress);
      AddressSpace = 0;
      v16 = HalTranslateBusAddress(Isa, 0, TranslatedAddress, &AddressSpace, &TranslatedAddress);
      if ( v10 && v16 )
      {
        CommitSize = TranslatedAddress.QuadPart - BusAddress.QuadPart;
        DbgPrint("PhysMemSizeInBytes = %llx", TranslatedAddress.QuadPart - BusAddress.QuadPart);
        SectionOffset = BusAddress;
        v15 = ZwMapViewOfSection(
                *SectionHandle,
                (HANDLE)0xFFFFFFFFFFFFFFFFi64,
                &BaseAddress,
                0i64,
                CommitSize,
                &SectionOffset,
                &CommitSize,
                ViewShare,
                0,
                0x204u);
        if ( v15 == -1073741800 )
          v15 = ZwMapViewOfSection(
                  *SectionHandle,
                  (HANDLE)0xFFFFFFFFFFFFFFFFi64,
                  &BaseAddress,
                  0i64,
                  CommitSize,
                  &SectionOffset,
                  &CommitSize,
                  ViewShare,
                  0,
                  4u);
        if ( v15 >= 0 )
        {
          DbgPrint("pStartPhysAddress = %llx", BusAddress.QuadPart);
          DbgPrint("ViewBase = %llx", SectionOffset.QuadPart);
          BaseAddress = (char *)BaseAddress + BusAddress.QuadPart - SectionOffset.QuadPart;
          DbgPrint("pbPhysMemLin = %llx", BaseAddress);
          DbgPrint("pPhysicalMemoryHandle = %llx", *SectionHandle);
          DbgPrint("pPhysSection = %llx", *Object);
          *v20 = BaseAddress;
        }
        else
        {
          DbgPrint("ERROR: ZwMapViewOfSection failed");
        }
      }
      else
      {
        DbgPrint("ERROR: HalTranslateBusAddress failed");
      }
    }
  }
  if ( v15 < 0 )
  {
    if ( a6 )
      ZwClose((HANDLE)v9);
    else
      ZwClose(*SectionHandle);
  }
  DbgPrint("Leaving MapPhysicalMemoryToLinearSpace");
  return (unsigned int)v15;
}
~~~

### IOCTL 0x80102050

This code triggers port in operation. The operation is eventually completed in function below.

```c
          case 0x80102050:
            DbgPrint("IOCTL_WINIO_READPORT");
            if ( Options )
            {
              qmemcpy(&v10, p_Type, Options);
              v21 = v12;
              if ( v12 == 1 )
              {
                v11 = (unsigned __int8)inbyte_func(v10);
              }
              else if ( v21 == 2 )
              {
                v11 = (unsigned __int16)inword_func(v10);
              }
              else if ( v21 == 4 )
              {
                v11 = indword_func(v10);
              }
              *p_Type = v11;
              a2->IoStatus.Information = 4i64;
            }
```



### IOCTL 0x80102054

This code triggers port out operation. The operation is eventually completed in function below.

```c
          case 0x80102054:
            DbgPrint("IOCTL_WINIO_WRITEPORT");
            if ( Options )
            {
              qmemcpy(&v10, p_Type, Options);
              v20 = v12;
              if ( v12 == 1 )
              {
                outbyte_func(v10, (unsigned __int8)v11);
              }
              else if ( v20 == 2 )
              {
                outword_func(v10, (unsigned __int16)v11);
              }
              else if ( v20 == 4 )
              {
                outdword_func(v10, v11);
              }
            }
```

