# Vulnerable Driver snxpcamd.sys in SUNIX Multi I/O Card - 10.1.0.0

---

Many vulnerability exists in driver snxpcamd.sys, which allows low-privileged users to read and write arbitary i/o port via specially crafted IOCTL requests . This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  



## version

10.1.0.0

## Vulnerability causes

snxpcamd.sys provides the functionality of read/write I/O ports, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

~~~c
__int64 __fastcall sub_140004530(__int64 a1, __int64 a2)
{
  _DWORD *v2; // r14
  unsigned int v3; // edi
  int v5; // ebx
  _DWORD *v6; // rdx
  unsigned int v7; // eax
  int v8; // eax
  unsigned int *v9; // rax
  int v10; // eax
  unsigned int *v11; // rax
  _OWORD *v12; // rax
  int *v13; // rcx
  __int64 v14; // rdx
  __int128 v15; // xmm1
  __int64 v16; // rax
  __int64 v17; // xmm0_8
  unsigned int *v18; // rax
  int v19; // eax
  __int64 v20; // rcx
  unsigned int v21; // r15d
  unsigned int v22; // r14d
  __int64 v23; // r8
  bool v24; // cf
  __int64 v25; // rcx
  __int64 v26; // rbx
  unsigned int v27; // r14d
  __int64 v28; // rdx
  __int64 v29; // rcx
  unsigned int v30; // r15d
  unsigned int v31; // r14d
  __int64 v32; // r8
  __int64 v33; // rbx
  unsigned int v34; // r15d
  unsigned int v35; // r14d
  __int64 v36; // r8
  __int64 v37; // rax
  __int64 v38; // xmm0_8
  unsigned int v39; // eax
  unsigned int v40; // eax
  __int64 v41; // r8
  __int64 v42; // rdx
  __int64 v43; // rcx
  unsigned int v44; // eax
  __int64 v45; // r8
  __int64 v46; // rdx
  __int64 v47; // rcx
  unsigned int v48; // eax
  unsigned int v49; // eax
  __int64 v51[2]; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v52; // [rsp+30h] [rbp-D0h] BYREF
  int v53; // [rsp+38h] [rbp-C8h]
  int v54; // [rsp+40h] [rbp-C0h] BYREF
  char v55[412]; // [rsp+44h] [rbp-BCh] BYREF

  v2 = *(_DWORD **)(a1 + 64);
  v3 = 0;
  v5 = 0;
  v6 = *(_DWORD **)(a2 + 184);
  if ( (*v2 & 1) == 0 )
  {
    v5 = -1073741823;
    goto LABEL_126;
  }
  v7 = v6[6];
  if ( v7 > 0x9C403008 )
  {
    if ( v7 > 0x9C403C40 )
    {
      switch ( v7 )
      {
        case 0x9C403C44:
          v24 = v6[4] < 8u;
          LODWORD(v51[0]) = 0;
          if ( v24 || v6[2] < 4u )
            goto LABEL_29;
          if ( v2[252] != -1 && v2[261] == 0x4000 )
          {
            v49 = sub_140007E2C(**(_QWORD **)(a2 + 24), (unsigned int)v2[259], (unsigned int)v2[260]);
            if ( v49 )
            {
              v10 = sub_140008524(v49, v51);
              goto LABEL_122;
            }
          }
          break;
        case 0x9C403C48:
          v24 = v6[4] < 8u;
          LODWORD(v51[0]) = 0;
          if ( v24 || v6[2] < 4u )
            goto LABEL_29;
          if ( v2[252] != -1 && v2[261] == 0x4000 )
          {
            v45 = (unsigned int)v2[260];
            v46 = (unsigned int)v2[259];
            v47 = (unsigned int)**(_QWORD **)(a2 + 24);
            v52 = **(_QWORD **)(a2 + 24);
            v48 = sub_140007E2C(v47, v46, v45);
            if ( v48 )
            {
              v10 = sub_140008128(v48, HIDWORD(v52), v51);
              goto LABEL_122;
            }
          }
          break;
        case 0x9C403C4C:
          v24 = v6[4] < 8u;
          LODWORD(v51[0]) = 0;
          if ( v24 || v6[2] < 4u )
            goto LABEL_29;
          if ( v2[252] != -1 && v2[261] == 0x4000 )
          {
            v41 = (unsigned int)v2[260];
            v42 = (unsigned int)v2[259];
            v43 = (unsigned int)**(_QWORD **)(a2 + 24);
            v52 = **(_QWORD **)(a2 + 24);
            v44 = sub_140007E2C(v43, v42, v41);
            if ( v44 )
            {
              v10 = sub_1400085E8(v44, HIDWORD(v52), v51);
              goto LABEL_122;
            }
          }
          break;
        case 0x9C403C80:
          v24 = v6[4] < 8u;
          LODWORD(v51[0]) = 0;
          if ( v24 || v6[2] < 4u )
            goto LABEL_29;
          v40 = v2[259];
          if ( v40 )
          {
            v10 = sub_140008038(v40, v51);
            goto LABEL_122;
          }
          break;
        case 0x9C403C84:
          if ( v6[4] < 8u )
            goto LABEL_29;
          if ( v2[259] )
          {
            v8 = sub_140008084((unsigned int)v2[259], HIDWORD(**(_QWORD **)(a2 + 24)));
            goto LABEL_76;
          }
          break;
        default:
          goto LABEL_95;
      }
    }
    else
    {
      switch ( v7 )
      {
        case 0x9C403C40:
          v24 = v6[4] < 8u;
          LODWORD(v51[0]) = 0;
          if ( v24 || v6[2] < 4u )
            goto LABEL_29;
          if ( v2[252] != -1 && v2[261] == 0x4000 )
          {
            v39 = sub_140007E2C(**(_QWORD **)(a2 + 24), (unsigned int)v2[259], (unsigned int)v2[260]);
            if ( v39 )
            {
              v10 = sub_140008380(v39, v51);
              goto LABEL_122;
            }
          }
          break;
        case 0x9C40300C:
          if ( v6[4] >= 0xCu )
          {
            v37 = *(_QWORD *)(a2 + 24);
            v38 = *(_QWORD *)v37;
            LODWORD(v37) = *(_DWORD *)(v37 + 8);
            v52 = v38;
            v53 = v37;
            v8 = sub_140005330(&v52);
            goto LABEL_76;
          }
          goto LABEL_29;
        case 0x9C403C00:
          v24 = v6[4] < 8u;
          LODWORD(v51[0]) = 0;
          if ( v24 || v6[2] < 4u )
            goto LABEL_29;
          if ( v2[252] != -1 )
          {
            v33 = **(_QWORD **)(a2 + 24);
            v34 = ((__int64 (*)(void))sub_140007D5C)();
            v35 = sub_140007E2C((unsigned int)v33, (unsigned int)v2[259], (unsigned int)v2[260]);
            if ( v35 )
            {
              LOBYTE(v36) = sub_140007D70((unsigned int)v33);
              v10 = sub_140007D7C(v34, v35, v36, v51);
              goto LABEL_122;
            }
          }
          break;
        case 0x9C403C04:
          if ( v6[4] < 8u )
            goto LABEL_29;
          v29 = (unsigned int)v2[252];
          if ( (_DWORD)v29 != -1 )
          {
            v51[0] = **(_QWORD **)(a2 + 24);
            v30 = sub_140007D5C(v29);
            v31 = sub_140007E2C(LODWORD(v51[0]), (unsigned int)v2[259], (unsigned int)v2[260]);
            if ( v31 )
            {
              LOBYTE(v32) = sub_140007D70(LODWORD(v51[0]));
              v8 = sub_140007EA4(v30, v31, v32, HIDWORD(v51[0]));
              goto LABEL_76;
            }
          }
          break;
        case 0x9C403C08:
          v24 = v6[4] < 8u;
          LODWORD(v51[0]) = 0;
          if ( v24 || v6[2] < 4u )
            goto LABEL_29;
          v25 = (unsigned int)v2[252];
          if ( (_DWORD)v25 != -1 )
          {
            v26 = **(_QWORD **)(a2 + 24);
            sub_140007D5C(v25);
            v27 = sub_140007E2C((unsigned int)v26, (unsigned int)v2[259], (unsigned int)v2[260]);
            if ( v27 )
            {
              LOBYTE(v28) = sub_140007D70((unsigned int)v26);
              v10 = sub_140007D38(v27, v28, v51);
              goto LABEL_122;
            }
          }
          break;
        case 0x9C403C0C:
          if ( v6[4] < 8u )
            goto LABEL_29;
          v20 = (unsigned int)v2[252];
          if ( (_DWORD)v20 != -1 )
          {
            v51[0] = **(_QWORD **)(a2 + 24);
            v21 = sub_140007D5C(v20);
            v22 = sub_140007E2C(LODWORD(v51[0]), (unsigned int)v2[259], (unsigned int)v2[260]);
            if ( v22 )
            {
              LOBYTE(v23) = sub_140007D70(LODWORD(v51[0]));
              v8 = sub_140007E50(v21, v22, v23, HIDWORD(v51[0]));
              goto LABEL_76;
            }
          }
          break;
        case 0x9C403C24:
          if ( v6[2] >= 4u )
          {
            v19 = v2[261];
            goto LABEL_124;
          }
          goto LABEL_29;
        default:
          goto LABEL_95;
      }
    }
    v5 = -1073741637;
    goto LABEL_126;
  }
  if ( v7 == -1673515000 )
  {
    if ( v6[4] >= 8u && v6[2] >= 4u )
    {
      v10 = sub_140004D6C(**(_QWORD **)(a2 + 24), v51);
      goto LABEL_122;
    }
    goto LABEL_29;
  }
  if ( v7 > 0x9C402C10 )
  {
    switch ( v7 )
    {
      case 0x9C402C14:
        if ( v6[4] >= 8u )
        {
          v8 = sub_1400055D8(**(_QWORD **)(a2 + 24));
          goto LABEL_76;
        }
        break;
      case 0x9C402C18:
        if ( v6[4] >= 4u && v6[2] >= 4u )
        {
          v18 = *(unsigned int **)(a2 + 24);
          LODWORD(v51[0]) = 0;
          v10 = sub_1400050EC(*v18, v51);
          goto LABEL_122;
        }
        break;
      case 0x9C402C1C:
        if ( v6[4] >= 8u )
        {
          v8 = sub_1400053C8(**(_QWORD **)(a2 + 24));
          goto LABEL_76;
        }
        break;
      case 0x9C403000:
        if ( v6[4] >= 8u && v6[2] >= 4u )
        {
          v10 = sub_140005290(**(_QWORD **)(a2 + 24), v51);
          goto LABEL_122;
        }
        break;
      case 0x9C403004:
        if ( v6[4] >= 0xCu )
        {
          v16 = *(_QWORD *)(a2 + 24);
          v17 = *(_QWORD *)v16;
          LODWORD(v16) = *(_DWORD *)(v16 + 8);
          v52 = v17;
          v53 = v16;
          v8 = sub_140005658(&v52);
          goto LABEL_76;
        }
        break;
      default:
        goto LABEL_95;
    }
    goto LABEL_29;
  }
  if ( v7 == -1673516016 )
  {
    if ( v6[4] >= 8u )
    {
      v8 = sub_140005558(**(_QWORD **)(a2 + 24));
      goto LABEL_76;
    }
    goto LABEL_29;
  }
  if ( v7 == -1673518080 )
  {
    if ( v6[2] >= 4u )
    {
      LODWORD(v51[0]) = 0;
      v10 = sub_140007670(L"Count", v51);
      goto LABEL_122;
    }
    goto LABEL_29;
  }
  if ( v7 != -1673518076 )
  {
    switch ( v7 )
    {
      case 0x9C402C00:
        if ( v6[4] >= 4u && v6[2] >= 4u )
        {
          v11 = *(unsigned int **)(a2 + 24);
          LODWORD(v51[0]) = 0;
          v10 = sub_140005178(*v11, v51);
          goto LABEL_122;
        }
        break;
      case 0x9C402C04:
        if ( v6[4] >= 8u )
        {
          v8 = sub_140005448(**(_QWORD **)(a2 + 24));
          goto LABEL_76;
        }
        break;
      case 0x9C402C08:
        if ( v6[4] >= 4u && v6[2] >= 4u )
        {
          v9 = *(unsigned int **)(a2 + 24);
          LODWORD(v51[0]) = 0;
          v10 = sub_140005204(*v9, v51);
LABEL_122:
          v5 = v10;
          if ( v10 < 0 )
            goto LABEL_126;
          v19 = v51[0];
LABEL_124:
          v3 = 4;
          **(_DWORD **)(a2 + 24) = v19;
          goto LABEL_126;
        }
        break;
      case 0x9C402C0C:
        if ( v6[4] >= 8u )
        {
          v8 = sub_1400054E4(**(_QWORD **)(a2 + 24));
LABEL_76:
          v5 = v8;
          goto LABEL_126;
        }
        break;
      default:
LABEL_95:
        v5 = -1073741670;
        goto LABEL_126;
    }
LABEL_29:
    v5 = -1073741789;
    goto LABEL_126;
  }
  if ( v6[4] < 4u || v6[2] < 0x1A0u )
    goto LABEL_29;
  sub_140008C40(v55, 0i64, 412i64);
  v54 = **(_DWORD **)(a2 + 24);
  v5 = sub_140004DDC(v2, &v54);
  if ( v5 >= 0 )
  {
    v12 = *(_OWORD **)(a2 + 24);
    v13 = &v54;
    v14 = 3i64;
    v3 = 416;
    do
    {
      *v12 = *(_OWORD *)v13;
      v12[1] = *((_OWORD *)v13 + 1);
      v12[2] = *((_OWORD *)v13 + 2);
      v12[3] = *((_OWORD *)v13 + 3);
      v12[4] = *((_OWORD *)v13 + 4);
      v12[5] = *((_OWORD *)v13 + 5);
      v12[6] = *((_OWORD *)v13 + 6);
      v12 += 8;
      v15 = *((_OWORD *)v13 + 7);
      v13 += 32;
      *(v12 - 1) = v15;
      --v14;
    }
    while ( v14 );
    *v12 = *(_OWORD *)v13;
    v12[1] = *((_OWORD *)v13 + 1);
  }
LABEL_126:
  sub_1400010DC(a2, (unsigned int)v5, v3);
  return (unsigned int)v5;
}
~~~

### IOCTL  0x9C402C00

This IOCTL code triggers the port in operation. 

~~~c
__int64 __fastcall sub_140003EFC(__int64 a1, __int64 a2, unsigned __int8 *a3, int a4)
{
  unsigned int v4; // r10d
  unsigned __int8 v5; // al
  unsigned __int8 v6; // al
  unsigned __int8 v7; // al
  unsigned __int8 v8; // al

  v4 = 0;
  switch ( a4 )
  {
    case 6:
      if ( a1 )
      {
        v8 = __inbyte(a1 + 13);
        goto LABEL_14;
      }
      break;
    case 8:
      if ( a2 )
        goto LABEL_10;
      break;
    case 16:
      if ( a2 )
        goto LABEL_8;
      break;
    default:
      if ( a4 == 32 && a2 )
      {
        v5 = __inbyte(a2 + 151);
        a3[3] = v5;
        v6 = __inbyte(a2 + 150);
        a3[2] = v6;
LABEL_8:
        v7 = __inbyte(a2 + 149);
        a3[1] = v7;
LABEL_10:
        v8 = __inbyte(a2 + 148);
LABEL_14:
        *a3 = v8;
        return v4;
      }
      break;
  }
  return (unsigned int)-1073741811;
}
~~~

### IOCTL 0x9C402C04

This code triggers port out operation. The operation is eventually completed in function below.

```c
__int64 __fastcall sub_1400040E8(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  unsigned int v4; // r10d

  v4 = 0;
  switch ( a4 )
  {
    case 6:
      if ( a1 )
      {
        __outbyte(a1 + 13, BYTE4(a3));
        return v4;
      }
      return (unsigned int)-1073741811;
    case 8:
      if ( a2 )
        goto LABEL_10;
      return (unsigned int)-1073741811;
    case 16:
      if ( a2 )
        goto LABEL_8;
      return (unsigned int)-1073741811;
  }
  if ( a4 != 32 || !a2 )
    return (unsigned int)-1073741811;
  __outbyte(a2 + 151, HIBYTE(a3));
  __outbyte(a2 + 150, BYTE6(a3));
LABEL_8:
  __outbyte(a2 + 149, BYTE5(a3));
LABEL_10:
  __outbyte(a2 + 148, BYTE4(a3));
  return v4;
}
```



