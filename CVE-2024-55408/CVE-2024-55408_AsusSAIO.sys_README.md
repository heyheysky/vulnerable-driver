# Vulnerable Driver AsusSAIO.sys in ASUS System Analysis IO - 1.0.0

---

Many vulnerability exits in driver AsusSAIO.sys, which allows low-privileged users to map arbitrary physical memory, read and write arbitary i/o port and even read/write arbitary MSR via specially crafted IOCTL requests . This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  



## version

1.0.0

## Vulnerability causes

AsUpIO64.sys  provides the functionality of mapping physical memory and read/write I/O ports and arbitrary read/write MSR, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

~~~c
__int64 __fastcall sub_140001180(__int64 a1, IRP *a2)
{
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rdx
  struct _IRP *MasterIrp; // rbx
  UCHAR MajorFunction; // al
  unsigned int Options; // ecx
  unsigned int Length; // esi
  unsigned int LowPart; // eax
  int v9; // eax
  __int128 v10; // xmm0
  int v11; // eax
  unsigned int Status; // ebx
  __int64 v14; // [rsp+20h] [rbp-50h] BYREF
  __int64 v15; // [rsp+28h] [rbp-48h] BYREF
  int MdlAddress; // [rsp+30h] [rbp-40h]
  _BYTE v17[20]; // [rsp+38h] [rbp-38h] BYREF
  char v18; // [rsp+4Ch] [rbp-24h]
  __int128 v19; // [rsp+50h] [rbp-20h]

  a2->IoStatus.Status = 0;
  a2->IoStatus.Information = 0i64;
  CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
  MasterIrp = a2->AssociatedIrp.MasterIrp;
  MajorFunction = CurrentStackLocation->MajorFunction;
  Options = CurrentStackLocation->Parameters.Create.Options;
  Length = CurrentStackLocation->Parameters.Read.Length;
  if ( !CurrentStackLocation->MajorFunction )
  {
    if ( dword_140005050 == -1 )
      goto LABEL_60;
    v11 = dword_140005050 + 1;
    goto LABEL_59;
  }
  if ( MajorFunction == 2 )
  {
    if ( dword_140005050 == -1 )
      goto LABEL_60;
    v11 = dword_140005050 - 1;
LABEL_59:
    dword_140005050 = v11;
    goto LABEL_60;
  }
  if ( MajorFunction != 14 )
    goto LABEL_60;
  LowPart = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
  if ( LowPart > 0x8010207C )
  {
    switch ( LowPart )
    {
      case 0x80102080:
        if ( !Length )
          goto LABEL_42;
        v14 = 0i64;
        sub_140002CE4(&v14);
        break;
      case 0x80102084:
        if ( !Length )
          goto LABEL_42;
        v14 = 0i64;
        sub_14000242C(&v14);
        break;
      case 0x80102088:
        if ( !Length )
          goto LABEL_42;
        v14 = 0i64;
        sub_140002628(&v14);
        break;
      case 0x8010208C:
        if ( !Length )
          goto LABEL_42;
        v14 = 0i64;
        sub_1400021F0(&v14);
        break;
      case 0x80102090:
        if ( !Length )
          goto LABEL_42;
        v14 = 0i64;
        sub_140001D74(&v14);
        break;
      default:
        if ( LowPart != -2146426732 || !Length )
          goto LABEL_42;
        v14 = 0i64;
        sub_14000202C(&v14);
        break;
    }
    goto LABEL_35;
  }
  switch ( LowPart )
  {
    case 0x8010207C:
      if ( !Length )
        goto LABEL_42;
      v14 = 0i64;
      sub_14000281C(&v14);
LABEL_35:
      *(_QWORD *)&MasterIrp->Type = v14;
      a2->IoStatus.Information = 8i64;
      goto LABEL_60;
    case 0x80102040:
      if ( !Length )
        goto LABEL_60;
      *(_DWORD *)&MasterIrp->Type = 65537;
      goto LABEL_32;
    case 0x80102044:
      if ( !Length )
        goto LABEL_60;
      *(_DWORD *)&MasterIrp->Type = dword_140005050;
LABEL_32:
      a2->IoStatus.Status = 0;
      a2->IoStatus.Information = 4i64;
      goto LABEL_60;
    case 0x80102068:
      if ( Options < 0x15 )
        goto LABEL_42;
      *(_OWORD *)v17 = *(_OWORD *)&MasterIrp->Type;
      *(_DWORD *)&v17[16] = MasterIrp->Flags;
      v18 = *((_BYTE *)&MasterIrp->Flags + 4);
      if ( (int)sub_140002E90(v17) < 0 || Length < 0x10 )
        goto LABEL_60;
      v10 = *(_OWORD *)&v17[4];
      goto LABEL_23;
    case 0x80102070:
      if ( Options < 0x10 )
        goto LABEL_42;
      v19 = *(_OWORD *)&MasterIrp->Type;
      if ( (int)sub_140001930(&Mutex) < 0 || Length < 0x10 )
        goto LABEL_60;
      v10 = v19;
LABEL_23:
      *(_OWORD *)&MasterIrp->Type = v10;
      a2->IoStatus.Information = 16i64;
      goto LABEL_60;
    case 0x80102074:
      if ( Options >= 0xC )
      {
        v15 = *(_QWORD *)&MasterIrp->Type;
        MdlAddress = (int)MasterIrp->MdlAddress;
        v9 = sub_14000295C(&v15);
        goto LABEL_14;
      }
LABEL_42:
      a2->IoStatus.Status = -1073741811;
      goto LABEL_60;
  }
  if ( LowPart != -2146426760 || Options < 0xC )
    goto LABEL_42;
  v15 = *(_QWORD *)&MasterIrp->Type;
  MdlAddress = (int)MasterIrp->MdlAddress;
  v9 = sub_140002B20(&v15);
LABEL_14:
  if ( v9 >= 0 && Length >= 0xC )
  {
    *(_QWORD *)&MasterIrp->Type = v15;
    LODWORD(MasterIrp->MdlAddress) = MdlAddress;
    a2->IoStatus.Information = 12i64;
  }
LABEL_60:
  Status = a2->IoStatus.Status;
  IofCompleteRequest(a2, 0);
  return Status;
}
~~~

### IOCTL  0x80102074

This IOCTL code triggers the memory mapping operation. 

~~~c
__int64 __fastcall sub_140001CA8(unsigned int *a1)
{
  unsigned int v2; // eax
  PHYSICAL_ADDRESS v3; // rcx
  unsigned int v4; // ebx
  SIZE_T v5; // rsi
  unsigned __int16 *v6; // rax
  void *v7; // rcx
  unsigned int v8; // ebx
  unsigned int v9; // ebx
  int v10; // r9d
  unsigned int v11; // eax

  if ( a1 )
  {
    v2 = *((unsigned __int8 *)a1 + 8);
    if ( (_BYTE)v2 )
    {
      v3.QuadPart = *a1;
      if ( v3.LowPart )
      {
        v4 = v2;
        v5 = v2;
        v6 = (unsigned __int16 *)MmMapIoSpace(v3, v2, MmNonCached);
        v7 = v6;
        v8 = v4 - 1;
        if ( v8 )
        {
          v9 = v8 - 1;
          if ( v9 )
          {
            if ( v9 != 2 )
            {
              if ( off_140005008 != &off_140005008 )
              {
                v10 = 11;
LABEL_15:
                sub_140001998(DeviceObject->DeviceExtension, 2, 2, v10, (__int64)&unk_140004120);
                return 3221225485i64;
              }
              return 3221225485i64;
            }
            v11 = *(_DWORD *)v6;
          }
          else
          {
            v11 = *v6;
          }
        }
        else
        {
          v11 = *(unsigned __int8 *)v6;
        }
        a1[1] = v11;
        MmUnmapIoSpace(v7, v5);
        return 0i64;
      }
    }
  }
  if ( off_140005008 != &off_140005008 )
  {
    v10 = 10;
    goto LABEL_15;
  }
  return 3221225485i64;
}
~~~

### IOCTL 0x80102090,0x80102094,0x8010208C,0x80102084,0x80102088,0x8010207C,0x80102074,0x80102080

This code triggers read msr operation. The operation is eventually completed in function below.

```c
__int64 __fastcall sub_140002F40(__int64 a1)
{
  if ( a1 )
  {
    *(_QWORD *)(a1 + 4) = __readmsr(*(_DWORD *)a1);
    return 0i64;
  }
  else
  {
    if ( off_140005008 != &off_140005008 )
      sub_140001998(DeviceObject->DeviceExtension, 2, 2, 10, (__int64)&unk_140004130);
    return 3221225485i64;
  }
}
```



### IOCTL 0x80102090,0x80102084,0x80102088

This code triggers msr write operation. The operation is eventually completed in function below.

```c
__int64 __fastcall sub_1400031D0(__int64 a1)
{
  if ( a1 )
  {
    __writemsr(*(_DWORD *)a1, *(_QWORD *)(a1 + 4));
    return 0i64;
  }
  else
  {
    if ( off_140005008 != &off_140005008 )
      sub_140001998(DeviceObject->DeviceExtension, 2, 2, 12, (__int64)&unk_140004130);
    return 3221225485i64;
  }
}
```

### IOCTL 0x80102070

This code triggers port in operation. The operation is eventually completed in function below.

```c
__int64 __fastcall sub_140001B5C(__int64 a1)
{
  unsigned __int16 v1; // r8
  int v2; // r9d
  unsigned __int32 v3; // eax

  if ( a1 )
  {
    v1 = *(_WORD *)a1;
    if ( *(_WORD *)a1 )
    {
      switch ( *(_BYTE *)(a1 + 6) )
      {
        case 1:
          LOBYTE(v3) = __inbyte(v1);
          v3 = (unsigned __int8)v3;
          break;
        case 2:
          LOWORD(v3) = __inword(v1);
          v3 = (unsigned __int16)v3;
          break;
        case 4:
          v3 = __indword(v1);
          break;
        default:
          if ( off_140005008 != &off_140005008 )
          {
            v2 = 13;
LABEL_14:
            sub_140001998(DeviceObject->DeviceExtension, 2, 2, v2, (__int64)&unk_140004110);
            return 3221225485i64;
          }
          return 3221225485i64;
      }
      *(_DWORD *)(a1 + 2) = v3;
      return 0i64;
    }
  }
  if ( off_140005008 != &off_140005008 )
  {
    v2 = 12;
    goto LABEL_14;
  }
  return 3221225485i64;
}
```

### IOCTL 0x80102070

This code triggers port in/out operation. The operation is eventually completed in function below.

```c
__int64 __fastcall sub_140001B5C_in(__int64 a1)
{
  unsigned __int16 v1; // r8
  int v2; // r9d
  unsigned __int32 v3; // eax

  if ( a1 )
  {
    v1 = *(_WORD *)a1;
    if ( *(_WORD *)a1 )
    {
      switch ( *(_BYTE *)(a1 + 6) )
      {
        case 1:
          LOBYTE(v3) = __inbyte(v1);
          v3 = (unsigned __int8)v3;
          break;
        case 2:
          LOWORD(v3) = __inword(v1);
          v3 = (unsigned __int16)v3;
          break;
        case 4:
          v3 = __indword(v1);
          break;
        default:
          if ( off_140005008 != &off_140005008 )
          {
            v2 = 13;
LABEL_14:
            sub_140001998(DeviceObject->DeviceExtension, 2, 2, v2, (__int64)&unk_140004110);
            return 3221225485i64;
          }
          return 3221225485i64;
      }
      *(_DWORD *)(a1 + 2) = v3;
      return 0i64;
    }
  }
  if ( off_140005008 != &off_140005008 )
  {
    v2 = 12;
    goto LABEL_14;
  }
  return 3221225485i64;
}


__int64 __fastcall sub_140001C00_out(__int64 a1)
{
  unsigned __int16 v1; // r8
  int v2; // r9d

  if ( a1 )
  {
    v1 = *(_WORD *)a1;
    if ( *(_WORD *)a1 )
    {
      switch ( *(_BYTE *)(a1 + 6) )
      {
        case 1:
          __outbyte(v1, *(_BYTE *)(a1 + 2));
          break;
        case 2:
          __outword(v1, *(_WORD *)(a1 + 2));
          break;
        case 4:
          __outdword(v1, *(_DWORD *)(a1 + 2));
          break;
        default:
          if ( off_140005008 != &off_140005008 )
          {
            v2 = 11;
LABEL_14:
            sub_140001998(DeviceObject->DeviceExtension, 2, 2, v2, (__int64)&unk_140004110);
            return 3221225485i64;
          }
          return 3221225485i64;
      }
      return 0i64;
    }
  }
  if ( off_140005008 != &off_140005008 )
  {
    v2 = 10;
    goto LABEL_14;
  }
  return 3221225485i64;
}
```

