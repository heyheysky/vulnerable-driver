# Vulnerable Driver snxppamd.sys in  SUNIX Parallel Driver x64 - 10.1.0.0

---

Many vulnerability exists in driver snxppamd.sys, which allows low-privileged users to read and write arbitary i/o port via specially crafted IOCTL requests . This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  



## version

10.1.0.0



## Vulnerability causes

snxpcamd.sys provides the functionality of read/write I/O ports, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

~~~c
__int64 __fastcall sub_14000869C(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  _DWORD *v3; // rcx
  int v5; // eax
  __int64 v6; // rdx
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  int v13; // ebx
  _WORD *v14; // rdx
  bool v15; // cf
  unsigned int v16; // ebx
  _WORD *v17; // rdx
  unsigned int v18; // eax
  unsigned int v19; // eax
  unsigned int v20; // eax
  unsigned int v21; // eax
  unsigned int v22; // eax
  unsigned int v23; // eax
  unsigned int v24; // eax
  unsigned int v25; // eax
  __int64 v26; // rdx
  __int64 v27; // rbx
  char v28; // al
  _QWORD *v29; // r14
  struct _KSEMAPHORE *v30; // r15
  LONG StateSemaphore; // eax
  char v32; // bp
  _QWORD *v33; // rax
  _QWORD *v34; // rdi
  __int64 v35; // rdx
  char v36; // si
  unsigned __int8 v37; // al
  __int64 v38; // rcx
  __int64 v39; // rcx
  __int64 v40; // rdx
  unsigned __int8 v41; // al
  __int64 v42; // rdx
  unsigned __int8 v43; // al
  __int64 v44; // rcx
  unsigned __int8 v45; // al
  unsigned __int8 v46; // al
  _DWORD *v47; // rcx
  _DWORD *v48; // rcx
  __int64 v49; // rcx
  unsigned __int8 v50; // [rsp+50h] [rbp+8h] BYREF
  KIRQL Irql; // [rsp+58h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(a1 + 64);
  v3 = *(_DWORD **)(a2 + 184);
  *(_QWORD *)(a2 + 56) = 0i64;
  v5 = *(_DWORD *)(v2 + 112);
  if ( (v5 & 0x40) != 0 || (v5 & 0x200) != 0 )
  {
    v6 = 3221225558i64;
    return sub_14001117C(a2, v6, 0i64);
  }
  if ( (v5 & 0x1200) != 0 )
  {
    v6 = 3221226166i64;
    return sub_14001117C(a2, v6, 0i64);
  }
  v8 = v3[6];
  if ( v8 > 0x160030 )
  {
    if ( v8 > 0x1B001C )
    {
      switch ( v8 )
      {
        case 0x1B0020u:
          if ( v3[2] < 0x14u )
            goto LABEL_17;
          v49 = *(_QWORD *)(a2 + 24);
          *(_OWORD *)v49 = 0i64;
          *(_DWORD *)(v49 + 16) = 0;
          *(_DWORD *)(v49 + 16) = 1000 * *(_DWORD *)(v2 + 292);
          *(_QWORD *)(a2 + 56) = 20i64;
          break;
        case 0x36323632u:
          if ( v3[2] < 4u )
            goto LABEL_17;
          if ( *(_DWORD *)(v2 + 1612) == -1 )
          {
            v13 = -1073741637;
            goto LABEL_107;
          }
          v48 = *(_DWORD **)(a2 + 24);
          *(_QWORD *)(a2 + 56) = 4i64;
          *v48 = *(_DWORD *)(v2 + 1612);
          break;
        case 0x89131987:
          break;
        case 0x9C403C80:
          if ( v3[2] >= 4u )
          {
            v42 = *(_QWORD *)(v2 + 1616) + 4i64;
            v43 = __inbyte(v42);
            if ( (v43 & 0x20) != 0 )
            {
              v44 = *(_QWORD *)(v2 + 1616);
              LOBYTE(v42) = 35;
              v50 = 0;
              v13 = sub_14001385C(v44, v42, &v50);
              v45 = (v50 >> 4) & 7;
              if ( v13 < 0 )
                goto LABEL_107;
            }
            else
            {
              v46 = __inbyte(*(_WORD *)(v2 + 496) + 2);
              v45 = v46 >> 5;
              v13 = 0;
            }
            v47 = *(_DWORD **)(a2 + 24);
            *(_QWORD *)(a2 + 56) = 4i64;
            *v47 = v45;
            goto LABEL_107;
          }
          goto LABEL_17;
        case 0x9C403C84:
          if ( v3[4] >= 4u )
          {
            v35 = *(_QWORD *)(v2 + 1616) + 4i64;
            v36 = **(_BYTE **)(a2 + 24);
            v37 = __inbyte(v35);
            if ( (v37 & 0x20) != 0 )
            {
              v38 = *(_QWORD *)(v2 + 1616);
              LOBYTE(v35) = 35;
              v50 = 0;
              sub_14001385C(v38, v35, &v50);
              v39 = *(_QWORD *)(v2 + 1616);
              LOBYTE(v40) = 35;
              v50 = (16 * v36) | v50 & 0x8F;
              v13 = sub_1400138D8(v39, v40);
              if ( v13 < 0 )
                goto LABEL_107;
            }
            else
            {
              v13 = 0;
            }
            v41 = __inbyte(*(_QWORD *)(v2 + 496) + 2);
            __outbyte(*(_WORD *)(v2 + 496) + 2, (32 * v36) | v41 & 0x1F);
            goto LABEL_107;
          }
          goto LABEL_17;
        default:
          goto LABEL_23;
      }
LABEL_106:
      v13 = 0;
      goto LABEL_107;
    }
    if ( v8 == 1769500 )
    {
      if ( v3[4] < 0x14u )
        goto LABEL_17;
      if ( *(_DWORD *)(*(_QWORD *)(a2 + 24) + 16i64) < 0x7D0u )
        goto LABEL_23;
      goto LABEL_73;
    }
    v22 = v8 - 1441844;
    if ( !v22 )
    {
      if ( v3[4] )
      {
        *(_BYTE *)(v2 + 790) = **(_BYTE **)(a2 + 24);
        goto LABEL_106;
      }
      goto LABEL_23;
    }
    v23 = v22 - 4;
    if ( v23 )
    {
      v24 = v23 - 4;
      if ( v24 )
      {
        v25 = v24 - 24;
        if ( v25 )
        {
          if ( v25 != 4 )
            goto LABEL_23;
          v26 = -1i64;
          do
            ++v26;
          while ( *(_BYTE *)(*(_QWORD *)(v2 + 8) + v26) );
          if ( v3[2] < (unsigned int)(v26 + 1) )
            goto LABEL_17;
          v27 = (unsigned int)v26 + 1i64;
          sub_140013D80(*(_QWORD *)(a2 + 24), *(_QWORD *)(v2 + 8), v27);
          *(_QWORD *)(a2 + 56) = v27;
          goto LABEL_106;
        }
        if ( !v3[2] )
          goto LABEL_17;
        if ( *(_BYTE *)(v2 + 592) || !(*(unsigned __int8 (__fastcall **)(_QWORD))(v2 + 512))(*(_QWORD *)(v2 + 536)) )
        {
          **(_BYTE **)(a2 + 24) = 0;
        }
        else
        {
          (*(void (__fastcall **)(_QWORD))(v2 + 520))(*(_QWORD *)(v2 + 536));
          **(_BYTE **)(a2 + 24) = 1;
        }
LABEL_63:
        *(_QWORD *)(a2 + 56) = 1i64;
        goto LABEL_106;
      }
      if ( !v3[2] )
        goto LABEL_17;
      v28 = *(_BYTE *)(v2 + 682);
    }
    else
    {
      if ( !v3[2] )
        goto LABEL_17;
      v28 = *(_BYTE *)(v2 + 683);
    }
    **(_BYTE **)(a2 + 24) = v28;
    goto LABEL_63;
  }
  if ( v8 == 1441840 )
    goto LABEL_44;
  if ( v8 <= 0x160018 )
  {
    if ( v8 != 1441816 )
    {
      v9 = v8 - 1441796;
      if ( !v9 )
      {
        v15 = v3[2] == 0;
LABEL_25:
        v16 = v15 ? 0xBFFFFF20 : 0;
LABEL_26:
        v13 = v16 + 259;
        goto LABEL_45;
      }
      v10 = v9 - 4;
      if ( v10 )
      {
        v11 = v10 - 4;
        if ( v11 )
        {
          v12 = v11 - 4;
          if ( v12 )
          {
            if ( v12 == 4 )
            {
              if ( v3[2] < 4u )
              {
LABEL_17:
                v13 = -1073741789;
                goto LABEL_107;
              }
              v14 = *(_WORD **)(a2 + 24);
              *v14 = word_140017488[40 * *(unsigned __int16 *)(v2 + 304)];
              v14[1] = *((_WORD *)&unk_140017278 + 32 * (unsigned __int64)*(unsigned __int16 *)(v2 + 302));
              goto LABEL_19;
            }
LABEL_23:
            v13 = -1073741811;
            goto LABEL_107;
          }
          v15 = v3[2] < 4u;
          goto LABEL_25;
        }
LABEL_44:
        v13 = v3[2] != 0 ? 259 : -1073741789;
LABEL_45:
        if ( v13 != 259 )
          goto LABEL_107;
        goto LABEL_74;
      }
      if ( !v3[4] )
        goto LABEL_17;
      if ( **(_BYTE **)(a2 + 24) != 1 )
        goto LABEL_23;
      goto LABEL_37;
    }
    if ( v3[4] < 4u || v3[2] < 4u )
      goto LABEL_23;
    v17 = *(_WORD **)(a2 + 24);
    if ( *v17 == word_140017488[40 * *(unsigned __int16 *)(v2 + 304)]
      && v17[1] == *((_WORD *)&unk_140017278 + 32 * (unsigned __int64)*(unsigned __int16 *)(v2 + 302)) )
    {
LABEL_19:
      *(_QWORD *)(a2 + 56) = 4i64;
      goto LABEL_106;
    }
LABEL_73:
    v13 = 259;
    goto LABEL_74;
  }
  v18 = v8 - 1441820;
  if ( !v18 || (v19 = v18 - 4) == 0 )
  {
    v16 = v3[4] == 0 ? 0xBFFFFF0A : 0;
    goto LABEL_26;
  }
  v20 = v19 - 4;
  if ( v20 )
  {
    v21 = v20 - 4;
    if ( !v21 )
    {
      if ( v3[2] < 4u )
        goto LABEL_17;
      **(_DWORD **)(a2 + 24) = 0x10000;
      goto LABEL_19;
    }
    if ( v21 != 4 )
      goto LABEL_23;
  }
  else if ( v3[2] < 2u || v3[4] < 2u )
  {
    goto LABEL_17;
  }
LABEL_37:
  v13 = 259;
LABEL_74:
  IoAcquireCancelSpinLock(&Irql);
  if ( !*(_BYTE *)(a2 + 68) )
  {
    v29 = (_QWORD *)(v2 + 432);
    v30 = (struct _KSEMAPHORE *)(v2 + 448);
    if ( (_QWORD *)*v29 != v29
      || (StateSemaphore = KeReadStateSemaphore((PRKSEMAPHORE)(v2 + 448)), v32 = 1, StateSemaphore) )
    {
      v32 = 0;
    }
    *(_BYTE *)(*(_QWORD *)(a2 + 184) + 3i64) |= 1u;
    _InterlockedExchange64((volatile __int64 *)(a2 + 104), (__int64)sub_140011990);
    v33 = (_QWORD *)v29[1];
    v34 = (_QWORD *)(a2 + 168);
    if ( (_QWORD *)*v33 != v29 )
      __fastfail(3u);
    *v34 = v29;
    v34[1] = v33;
    *v33 = v34;
    v29[1] = v34;
    IoReleaseCancelSpinLock(Irql);
    if ( v32 )
      KeReleaseSemaphore(v30, 0, 1, 0);
    return (unsigned int)v13;
  }
  IoReleaseCancelSpinLock(Irql);
  v13 = -1073741536;
LABEL_107:
  sub_14001117C(a2, (unsigned int)v13, *(_QWORD *)(a2 + 56));
  return (unsigned int)v13;
}
~~~

### IOCTL  0x9C403C84

This IOCTL code triggers the port in operation. 

~~~c
        case 0x9C403C84:
          if ( v3[4] >= 4u )
          {
            v35 = *(_QWORD *)(v2 + 1616) + 4i64;
            v36 = **(_BYTE **)(a2 + 24);
            v37 = __inbyte(v35);
            if ( (v37 & 0x20) != 0 )
            {
              v38 = *(_QWORD *)(v2 + 1616);
              LOBYTE(v35) = 35;
              v50 = 0;
              sub_14001385C(v38, v35, &v50);
              v39 = *(_QWORD *)(v2 + 1616);
              LOBYTE(v40) = 35;
              v50 = (16 * v36) | v50 & 0x8F;
              v13 = sub_1400138D8(v39, v40);
              if ( v13 < 0 )
                goto LABEL_107;
            }
~~~

### IOCTL 0x9C403C84

This code triggers port out operation. The operation is eventually completed in function below.

```c
__int64 __fastcall sub_14001385C(__int16 a1, unsigned __int8 a2, _BYTE *a3)
{
  unsigned __int16 v3; // r9
  int v4; // r10d
  unsigned __int16 v5; // di
  unsigned __int16 v6; // r11
  unsigned int v7; // ecx
  unsigned __int8 v8; // al
  unsigned int v9; // ecx
  unsigned __int8 v10; // al
  unsigned __int8 v11; // al
  unsigned __int8 v12; // al

  v3 = a1 + 8;
  v4 = 0;
  v5 = a1 + 9;
  v6 = a1 + 10;
LABEL_2:
  v7 = 0;
  while ( 1 )
  {
    v8 = __inbyte(v3);
    if ( v7 > 0x3E8 )
      return 3221225626i64;
    ++v7;
    if ( (v8 & 1) == 0 )
    {
      __outbyte(v5, a2);
      __outbyte(v3, 1u);
      v9 = 0;
      while ( 1 )
      {
        v10 = __inbyte(v3);
        if ( v9 > 0x3E8 )
          return 3221225626i64;
        ++v9;
        if ( (v10 & 1) == 0 )
        {
          v11 = __inbyte(v3);
          if ( (unsigned int)++v4 > 0x64 )
            return 3221225626i64;
          if ( (v11 & 4) == 0 )
          {
            v12 = __inbyte(v6);
            *a3 = v12;
            return 0i64;
          }
          goto LABEL_2;
        }
      }
    }
  }
}
```



