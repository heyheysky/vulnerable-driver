# Vulnerable Driver SmSerl64.sys in Motorola SM56 Modem WDM Driver - 6.12.23.0

---

Many vulnerability exists in driver SmSerl64.sys, which allows low-privileged users to mapping physical memory via specially crafted IOCTL requests . This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  



## version

6.12.23.0

## Vulnerability causes

snxpcamd.sys provides the functionality of read/write I/O ports, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

~~~c
__int64 __fastcall SmSrlIoControl(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  _DWORD *v3; // rbx
  __int64 v5; // rcx
  unsigned int v7; // edi
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // eax
  unsigned int v15; // eax
  unsigned int started; // eax
  CCHAR v17; // dl
  __int64 v19; // rax
  __int64 v20; // rcx
  __int64 v21; // rcx
  __int64 (__fastcall *v22)(); // r9
  unsigned int v23; // ebx
  __int64 v24; // rax
  __int64 v25; // rcx
  unsigned int v26; // eax
  unsigned int v27; // eax
  unsigned int v28; // eax
  unsigned int v29; // eax
  unsigned int v30; // eax
  unsigned int v31; // eax
  __int64 v32; // rsi
  unsigned int v33; // eax
  unsigned int v34; // eax
  unsigned int v35; // eax
  unsigned int v36; // eax
  unsigned int v37; // eax
  unsigned int v38; // eax
  unsigned int v39; // eax
  KIRQL v40; // al
  __int64 v41; // rdx
  __int64 v42; // rcx
  KIRQL v43; // al
  KIRQL v44; // al
  __int64 v45; // rdx
  int v46; // eax
  int v47; // ebx
  __int64 v48; // rcx
  int v49; // eax
  KIRQL v50; // dl
  unsigned int v51; // eax
  unsigned int v52; // eax
  unsigned int v53; // eax
  unsigned int v54; // eax
  unsigned int v55; // eax
  unsigned int v56; // eax
  unsigned int v57; // eax
  int v58; // ebx
  __int64 v59; // rax
  _DWORD *v60; // rcx
  __int64 v61; // rcx
  __int64 v62; // rcx
  unsigned int v63; // eax
  unsigned int v64; // eax
  unsigned int v65; // eax
  unsigned int v66; // eax
  unsigned int v67; // eax
  unsigned int v68; // eax
  unsigned int v69; // eax
  KIRQL v70; // al
  int v71; // edx
  KIRQL v72; // al
  __int64 v73; // rdx
  KIRQL v74; // al
  __int64 v75; // rdx
  KIRQL v76; // al
  __int64 v77; // rbx
  KIRQL v78; // r12
  char v79; // r11
  __int64 v80; // rcx
  KIRQL v81; // al
  __int64 v82; // rbx
  __int64 v83; // r11
  KIRQL v84; // al
  _BYTE *v85; // rbx
  unsigned __int64 v86; // r11
  char v87; // al
  KIRQL v88; // al
  _DWORD *v89; // rbx
  int v90; // eax
  _DWORD *v91; // rax
  __int64 v92; // rbx
  int v93; // edx
  int v94; // eax
  int v95; // eax
  unsigned int v96; // eax
  unsigned int v97; // eax
  unsigned int v98; // eax
  unsigned int v99; // eax
  unsigned int v100; // eax
  unsigned int v101; // eax
  _QWORD *v102; // rcx
  _DWORD *v103; // rax
  char *v104; // rbx
  char v105; // dl
  KIRQL v106; // al
  __int64 v107; // rdx
  int v108[4]; // [rsp+20h] [rbp-98h] BYREF
  char v109[48]; // [rsp+30h] [rbp-88h] BYREF
  _DWORD v110[4]; // [rsp+60h] [rbp-58h] BYREF
  unsigned __int64 v111; // [rsp+70h] [rbp-48h]
  __int64 v112; // [rsp+78h] [rbp-40h]
  KIRQL NewIrql; // [rsp+C0h] [rbp+8h] BYREF
  int v114; // [rsp+C8h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(a1 + 64);
  v3 = *(_DWORD **)(a2 + 184);
  v5 = g_pDeviceExtension;
  v7 = 0;
  if ( (*(_BYTE *)(g_pDeviceExtension + 112) & 4) != 0 )
    v5 = g_pDeviceExtension;
  v8 = v3[6];
  *(_QWORD *)(a2 + 56) = 0i64;
  if ( v2 == g_psmdspDeviceExtension )
  {
    if ( v8 <= 0x1B2890 )
    {
      if ( v8 == 1779856 )
      {
LABEL_14:
        started = smdspDispatchDeviceIoControl(a1, a2);
LABEL_15:
        v7 = started;
        goto LABEL_16;
      }
      v9 = v8 - 1778197;
      if ( v9 && (v10 = v9 - 5) != 0 )
      {
        v11 = v10 - 4;
        if ( v11 )
        {
          v12 = v11 - 2;
          if ( v12 )
          {
            v13 = v12 - 1632;
            if ( !v13 )
              goto LABEL_14;
            v14 = v13 - 4;
            if ( !v14 )
              goto LABEL_14;
            v15 = v14 - 4;
            if ( !v15 || v15 == 4 )
              goto LABEL_14;
            goto LABEL_37;
          }
          if ( v3[4] == 32 )
            return smdspSM56AppIO(a1, a2);
LABEL_19:
          v7 = -1073741811;
          goto LABEL_16;
        }
        v19 = *(_QWORD *)(a1 + 64);
        v20 = *(_QWORD *)(*(_QWORD *)(v19 + 33) + 36i64);
        if ( v20 && *(_WORD *)(*(_QWORD *)(v19 + 102) + 558i64) )
        {
          v21 = *(_QWORD *)(v20 + 8);
          v22 = sub_15800;
          return (unsigned int)StartPacket(v21, a1, a2, v22);
        }
      }
      else
      {
        v24 = *(_QWORD *)(a1 + 64);
        v25 = *(_QWORD *)(*(_QWORD *)(v24 + 33) + 36i64);
        if ( v25 && *(_WORD *)(*(_QWORD *)(v24 + 102) + 580i64) )
        {
          v21 = *(_QWORD *)(v25 + 16);
          v22 = sub_15B48;
          return (unsigned int)StartPacket(v21, a1, a2, v22);
        }
      }
      v23 = -1073741536;
      *(_DWORD *)(a2 + 48) = -1073741536;
      IofCompleteRequest((PIRP)a2, 2);
      return v23;
    }
    v26 = v8 - 1779860;
    if ( !v26 )
      goto LABEL_14;
    v27 = v26 - 44;
    if ( !v27 )
      goto LABEL_14;
    v28 = v27 - 4;
    if ( !v28 )
      goto LABEL_14;
    v29 = v28 - 4;
    if ( !v29 )
      goto LABEL_14;
    v30 = v29 - 4;
    if ( !v30 || (v31 = v30 - 4) == 0 || v31 == 4 )
    {
      started = CaptureModuleIoControl(a1, a2);
      goto LABEL_15;
    }
LABEL_37:
    v7 = -1073741808;
    goto LABEL_16;
  }
  if ( v2 != v5 )
  {
    v7 = -1073741811;
    *(_DWORD *)(a2 + 48) = -1073741811;
    v17 = 0;
    goto LABEL_173;
  }
  v32 = *(_QWORD *)(v2 + 48);
  if ( v8 <= 0x1B0048 )
  {
    if ( v8 == 1769544 )
    {
      if ( v3[2] >= 4u )
        return StartPacket(
                 *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 16i64) + 36i64)
                           + 8i64 * *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 16i64) + 52i64)),
                 a1,
                 a2,
                 SmSrlCancelEvent);
      goto LABEL_169;
    }
    if ( v8 > 0x1B0024 )
    {
      v51 = v8 - 1769512;
      if ( v51 )
      {
        v52 = v51 - 4;
        if ( !v52 )
          goto LABEL_16;
        v53 = v52 - 4;
        if ( v53 )
        {
          v54 = v53 - 4;
          if ( v54 )
          {
            v55 = v54 - 4;
            if ( v55 )
            {
              v56 = v55 - 4;
              if ( v56 )
              {
                v57 = v56 - 4;
                if ( v57 )
                {
                  if ( v57 != 4 )
                    goto LABEL_37;
                  if ( v3[4] >= 4u )
                  {
                    v58 = **(_DWORD **)(a2 + 24);
                    if ( (v58 & 0xFFFFE000) != 0 )
                      goto LABEL_19;
                    SmSrlCompleteOldEvent(a1);
                    ++SpinLockCtr;
                    NewIrql = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
                    v59 = *(_QWORD *)(v32 + 858);
                    *(_DWORD *)(v32 + 821) = v58;
                    dword_13B7A8 = v58;
                    *(_DWORD *)(v59 + 20) = 0;
                    goto LABEL_68;
                  }
                }
                else if ( v3[2] >= 4u )
                {
                  v60 = *(_DWORD **)(a2 + 24);
                  *(_QWORD *)(a2 + 56) = 4i64;
                  *v60 = *(_DWORD *)(v32 + 821);
                  goto LABEL_16;
                }
                goto LABEL_169;
              }
              ++SpinLockCtr;
              v43 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
              byte_13B86E = 0;
            }
            else
            {
              ++SpinLockCtr;
              v43 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
              byte_13B86E = 1;
            }
LABEL_87:
            dword_13B6B4 = 0;
            NewIrql = v43;
            if ( SpinLockCtr )
            {
              --SpinLockCtr;
              v50 = v43;
              goto LABEL_71;
            }
            goto LABEL_16;
          }
        }
        ++SpinLockCtr;
        NewIrql = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
        v61 = *(_QWORD *)(v32 + 858);
        if ( v3[6] == 1769520 )
        {
          DD_PortEscapeFunction(v61, 3i64, 0i64, 0i64);
          *(_DWORD *)(v32 + 872) |= 2u;
        }
        else
        {
          DD_PortEscapeFunction(v61, 4i64, 0i64, 0i64);
          *(_DWORD *)(v32 + 872) &= ~2u;
        }
        goto LABEL_97;
      }
    }
    else if ( v8 != 1769508 )
    {
      v33 = v8 - 1769476;
      if ( v33 )
      {
        v34 = v33 - 4;
        if ( !v34 )
          goto LABEL_16;
        v35 = v34 - 4;
        if ( v35 )
        {
          v36 = v35 - 4;
          if ( v36 )
          {
            v37 = v36 - 4;
            if ( v37 )
            {
              v38 = v37 - 4;
              if ( v38 )
              {
                v39 = v38 - 4;
                if ( v39 )
                {
                  if ( v39 != 4 )
                    goto LABEL_37;
                  if ( v3[2] >= 0x14u )
                  {
                    ++SpinLockCtr;
                    v40 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
                    v41 = *(_QWORD *)(a2 + 24);
                    NewIrql = v40;
                    *(_QWORD *)v41 = *(_QWORD *)(v32 + 80);
                    *(_QWORD *)(v41 + 8) = *(_QWORD *)(v32 + 88);
                    *(_DWORD *)(v41 + 16) = *(_DWORD *)(v32 + 96);
                    *(_QWORD *)(a2 + 56) = 20i64;
LABEL_68:
                    v49 = SpinLockCtr;
                    if ( !SpinLockCtr )
                      goto LABEL_16;
                    v50 = NewIrql;
                    goto LABEL_70;
                  }
                }
                else if ( v3[4] >= 0x14u )
                {
                  started = sub_1338C(v32, *(_QWORD *)(a2 + 24));
                  goto LABEL_15;
                }
              }
              else if ( v3[4] )
              {
                ++SpinLockCtr;
                NewIrql = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
                v42 = *(_QWORD *)(v32 + 858);
                *(_BYTE *)(v32 + 857) = **(_BYTE **)(a2 + 24);
                DD_PortTransmitChar(v42);
                if ( *(_DWORD *)(*(_QWORD *)(v32 + 858) + 20i64) == 0x4000 )
                {
                  v7 = -1073741811;
                  *(_QWORD *)(a2 + 56) = 0i64;
                }
                else
                {
                  *(_QWORD *)(a2 + 56) = 1i64;
                }
                goto LABEL_68;
              }
              goto LABEL_169;
            }
            ++SpinLockCtr;
            v43 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
            byte_13B86B = 0;
          }
          else
          {
            ++SpinLockCtr;
            v43 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
            byte_13B86B = 1;
          }
          goto LABEL_87;
        }
        if ( v3[4] >= 3u )
        {
          ++SpinLockCtr;
          v44 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
          v45 = *(_QWORD *)(a2 + 24);
          NewIrql = v44;
          v46 = sub_132B4(v32, v45);
LABEL_67:
          v7 = v46;
          goto LABEL_68;
        }
      }
      else if ( v3[4] >= 4u )
      {
        ++SpinLockCtr;
        NewIrql = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
        v47 = **(_DWORD **)(a2 + 24);
        dword_13B6B4 = 0;
        memmove(v110, &dword_13B758, 0x30ui64);
        v48 = *(_QWORD *)(v32 + 858);
        v110[1] = v47;
        DD_PortSetCommState(v48, v110, 1i64);
        v46 = 0;
        if ( *(_DWORD *)(*(_QWORD *)(v32 + 858) + 20i64) == -12 )
          v46 = -1073741811;
        goto LABEL_67;
      }
      goto LABEL_169;
    }
    ++SpinLockCtr;
    NewIrql = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
    v50 = NewIrql;
    if ( (*(_BYTE *)(v32 + 845) & 3) == 2 )
    {
      v7 = -1073741811;
      goto LABEL_98;
    }
    v62 = *(_QWORD *)(v32 + 858);
    if ( v3[6] == 1769508 )
    {
      DD_PortEscapeFunction(v62, 5i64, 0i64, 0i64);
      *(_DWORD *)(v32 + 872) |= 1u;
    }
    else
    {
      DD_PortEscapeFunction(v62, 6i64, 0i64, 0i64);
      *(_DWORD *)(v32 + 872) &= ~1u;
    }
LABEL_97:
    v50 = NewIrql;
LABEL_98:
    v49 = SpinLockCtr;
    if ( !SpinLockCtr )
      goto LABEL_16;
    goto LABEL_70;
  }
  if ( v8 <= 0x1B006C )
  {
    if ( v8 == 1769580 )
    {
      if ( v3[2] >= 0x14u )
      {
        v92 = *(_QWORD *)(a2 + 24);
        ++CancelSpinCtr;
        v114 = 0;
        *(_QWORD *)(a2 + 56) = 20i64;
        IoAcquireCancelSpinLock(&NewIrql);
        DD_PortClearError(*(_QWORD *)(v32 + 858), v108, &v114);
        v93 = v114;
        *(_DWORD *)(v92 + 4) = v108[0];
        v94 = v108[1];
        *(_DWORD *)v92 = v93;
        *(_DWORD *)(v92 + 8) = v94;
        v95 = v108[2];
        *(_BYTE *)(v92 + 16) = 0;
        *(_DWORD *)(v92 + 12) = v95;
        *(_BYTE *)(v92 + 17) = *(_BYTE *)(v32 + 813);
        if ( CancelSpinCtr == 1 )
        {
          IoReleaseCancelSpinLock(NewIrql);
          --CancelSpinCtr;
        }
        else
        {
          IoReleaseCancelSpinLock(NewIrql);
        }
        goto LABEL_16;
      }
      goto LABEL_169;
    }
    v63 = v8 - 1769548;
    if ( !v63 )
    {
      v91 = *(_DWORD **)(a2 + 24);
      if ( v91 && *v91 && (*v91 & 0xFFFFFFF0) == 0 )
      {
        started = SmSrlStartPurge(a1, a2);
        goto LABEL_15;
      }
      goto LABEL_19;
    }
    v64 = v63 - 4;
    if ( !v64 )
    {
      if ( v3[2] >= 4u )
      {
        ++SpinLockCtr;
        v88 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
        v89 = *(_DWORD **)(a2 + 24);
        NewIrql = v88;
        dword_13B6B4 = 0;
        memmove(v110, &dword_13B758, 0x30ui64);
        v90 = SpinLockCtr;
        *v89 = v110[1];
        if ( v90 )
        {
          SpinLockCtr = v90 - 1;
          KeReleaseSpinLock((PKSPIN_LOCK)(v32 + 100), NewIrql);
        }
        *(_QWORD *)(a2 + 56) = 4i64;
        goto LABEL_16;
      }
      goto LABEL_169;
    }
    v65 = v64 - 4;
    if ( !v65 )
    {
      if ( v3[2] >= 3u )
      {
        ++SpinLockCtr;
        v84 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
        v85 = *(_BYTE **)(a2 + 24);
        NewIrql = v84;
        dword_13B6B4 = 0;
        memmove(v110, &dword_13B758, 0x30ui64);
        v86 = HIBYTE(v111);
        v85[2] = BYTE6(v111);
        v87 = v112;
        v85[1] = v86;
        *v85 = v87;
        *(_QWORD *)(a2 + 56) = 3i64;
        goto LABEL_68;
      }
      goto LABEL_169;
    }
    v66 = v65 - 4;
    if ( !v66 )
    {
      if ( v3[2] >= 6u )
      {
        ++SpinLockCtr;
        v81 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
        v82 = *(_QWORD *)(a2 + 24);
        NewIrql = v81;
        dword_13B6B4 = 0;
        memmove(v110, &dword_13B758, 0x30ui64);
        v83 = v112;
        *(_BYTE *)(v32 + 819) = BYTE1(v112);
        *(_BYTE *)(v32 + 820) = BYTE2(v83);
        *(_BYTE *)(v32 + 816) = BYTE3(v83);
        *(_BYTE *)(v32 + 818) = BYTE5(v83);
        *(_BYTE *)(v32 + 815) = BYTE4(v83);
        *(_DWORD *)v82 = *(_DWORD *)(v32 + 815);
        *(_WORD *)(v82 + 4) = *(_WORD *)(v32 + 819);
        *(_QWORD *)(a2 + 56) = 6i64;
        goto LABEL_68;
      }
      goto LABEL_169;
    }
    v67 = v66 - 4;
    if ( v67 )
    {
      v68 = v67 - 4;
      if ( !v68 )
      {
        if ( v3[2] >= 0x10u )
        {
          ++SpinLockCtr;
          v74 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
          v75 = *(_QWORD *)(a2 + 24);
          NewIrql = v74;
          v46 = sub_134DC(v32, v75);
          *(_QWORD *)(a2 + 56) = 16i64;
          goto LABEL_67;
        }
        goto LABEL_169;
      }
      v69 = v68 - 4;
      if ( !v69 )
      {
        if ( v3[4] >= 0x10u )
        {
          ++SpinLockCtr;
          v72 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
          v73 = *(_QWORD *)(a2 + 24);
          NewIrql = v72;
          v46 = sub_135B4(v32, v73);
          goto LABEL_67;
        }
LABEL_169:
        v7 = -1073741789;
        goto LABEL_16;
      }
      if ( v69 != 4 )
        goto LABEL_37;
      if ( v3[2] < 4u )
        goto LABEL_169;
      ++SpinLockCtr;
      v70 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
      *(_QWORD *)(a2 + 56) = 4i64;
      NewIrql = v70;
      *(_DWORD *)(*(_QWORD *)(v32 + 858) + 20i64) = 0;
      v71 = *(_BYTE *)qword_13B83C & 0xF0;
LABEL_114:
      **(_DWORD **)(a2 + 24) = v71;
      goto LABEL_68;
    }
    if ( v3[4] < 6u )
      goto LABEL_169;
    ++SpinLockCtr;
    v76 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
    v77 = *(_QWORD *)(a2 + 24);
    v78 = v76;
    NewIrql = v76;
    dword_13B6B4 = 0;
    memmove(v109, &dword_13B758, 0x30ui64);
    v79 = *(_BYTE *)(v32 + 814);
    if ( v79 && (v79 == *(_BYTE *)(v77 + 4) || v79 == *(_BYTE *)(v77 + 5)) )
    {
      v7 = -1073741811;
    }
    else
    {
      v80 = *(_QWORD *)(v32 + 858);
      *(_DWORD *)(v32 + 815) = *(_DWORD *)v77;
      *(_WORD *)(v32 + 819) = *(_WORD *)(v77 + 4);
      v109[25] = *(_BYTE *)(v77 + 4);
      v109[26] = *(_BYTE *)(v77 + 5);
      v109[27] = *(_BYTE *)(v77 + 1);
      v109[28] = *(_BYTE *)v77;
      v109[29] = *(_BYTE *)(v77 + 3);
      DD_PortSetCommState(v80, v109, 0i64);
      v78 = NewIrql;
    }
    v49 = SpinLockCtr;
    if ( !SpinLockCtr )
      goto LABEL_16;
    v50 = v78;
LABEL_70:
    SpinLockCtr = v49 - 1;
LABEL_71:
    KeReleaseSpinLock((PKSPIN_LOCK)(v32 + 100), v50);
    goto LABEL_16;
  }
  v96 = v8 - 1769584;
  if ( !v96 )
  {
    if ( v3[4] >= 0xCu )
    {
      if ( *(int *)(*(_QWORD *)(a2 + 24) + 4i64) > 0 )
        return SmSrlWrite(a1, a2);
      goto LABEL_19;
    }
    goto LABEL_169;
  }
  v97 = v96 - 4;
  if ( !v97 )
  {
    if ( v3[2] >= 0x40u )
    {
      ++SpinLockCtr;
      v106 = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
      v107 = *(_QWORD *)(a2 + 24);
      NewIrql = v106;
      DD_PortGetProperties(*(_QWORD *)(v32 + 858), v107);
      *(_QWORD *)(a2 + 56) = 64i64;
      goto LABEL_68;
    }
    goto LABEL_169;
  }
  v98 = v97 - 4;
  if ( !v98 )
  {
    if ( v3[2] < 4u )
      goto LABEL_169;
    ++SpinLockCtr;
    *(_QWORD *)(a2 + 56) = 4i64;
    NewIrql = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
    *(_DWORD *)(v32 + 872) &= 3u;
    v71 = *(_DWORD *)(v32 + 872);
    goto LABEL_114;
  }
  v99 = v98 - 4;
  if ( !v99 )
  {
    if ( !v3[4] )
      goto LABEL_169;
    v104 = *(char **)(a2 + 24);
    ++SpinLockCtr;
    NewIrql = KeAcquireSpinLockRaiseToDpc((PKSPIN_LOCK)(v32 + 100));
    v105 = *v104;
    if ( *v104 && (v105 == *(_BYTE *)(v32 + 820) || v105 == *(_BYTE *)(v32 + 819) || (*(_BYTE *)(v32 + 845) & 4) != 0) )
    {
      v7 = -1073741811;
    }
    else
    {
      byte_13B872 = *v104;
      dword_13B6B4 = 0;
    }
    v49 = SpinLockCtr;
    if ( !SpinLockCtr )
      goto LABEL_16;
    v50 = NewIrql;
    goto LABEL_70;
  }
  v100 = v99 - 4;
  if ( !v100 )
  {
    if ( v3[2] >= 4u )
    {
      v103 = *(_DWORD **)(a2 + 24);
      *(_QWORD *)(a2 + 56) = 4i64;
      *v103 = 0;
      goto LABEL_16;
    }
    goto LABEL_169;
  }
  v101 = v100 - 12;
  if ( !v101 )
  {
    if ( v3[2] >= 0x18u )
    {
      v102 = *(_QWORD **)(a2 + 24);
      *(_QWORD *)(a2 + 56) = 24i64;
      *v102 = *(_QWORD *)(v32 + 56);
      v102[1] = *(_QWORD *)(v32 + 64);
      v102[2] = *(_QWORD *)(v32 + 72);
      goto LABEL_16;
    }
    goto LABEL_169;
  }
  if ( v101 != 4 )
    goto LABEL_37;
  *(_DWORD *)(v32 + 76) = 0;
  *(_DWORD *)(v32 + 72) = 0;
  *(_DWORD *)(v32 + 68) = 0;
  *(_DWORD *)(v32 + 64) = 0;
  *(_DWORD *)(v32 + 60) = 0;
  *(_DWORD *)(v32 + 56) = 0;
LABEL_16:
  *(_DWORD *)(a2 + 48) = v7;
  if ( v7 != 259 )
  {
    *(_DWORD *)(a2 + 48) = v7;
    v17 = 2;
LABEL_173:
    IofCompleteRequest((PIRP)a2, v17);
  }
  return v7;
}
~~~

### IOCTL  0x1B2890,0x1B2880

This IOCTL code triggers the memory mapping operation. 

~~~c
    
    case 0x1B2890:
      v8 = IoAllocateMdl(**(PVOID **)(a2 + 24), *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8i64), 0, 0, 0i64);
      *(_QWORD *)(v3 + 118) = v8;
      if ( v8 )
      {
        MmProbeAndLockPages(v8, 0, IoModifyAccess);
        v9 = *(_QWORD *)(v3 + 118);
        v10 = (*(_BYTE *)(v9 + 10) & 5) != 0
            ? *(PVOID *)(v9 + 24)
            : MmMapLockedPagesSpecifyCache((PMDL)v9, 0, MmCached, 0i64, 0, 0x10u);
        DspLogData = (__int64)v10;
        DspLogData_log_ptr = 0;
        if ( v10 )
          goto LABEL_19;

case 0x1B2880:
      Mdl = IoAllocateMdl(**(PVOID **)(a2 + 24), *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8i64), 0, 0, 0i64);
      *(_QWORD *)(v3 + 126) = Mdl;
      if ( Mdl )
      {
        MmProbeAndLockPages(Mdl, 0, IoModifyAccess);
        v12 = *(_QWORD *)(v3 + 126);
        v13 = (*(_BYTE *)(v12 + 10) & 5) != 0
            ? *(PVOID *)(v12 + 24)
            : MmMapLockedPagesSpecifyCache((PMDL)v12, 0, MmCached, 0i64, 0, 0x10u);
        VxD_WinEpgData = (__int64)v13;
        if ( v13 )
          v5 = 0;
      }
      break;
~~~

